import {EventHandler, ExecutionResponse, Execution, CommandHandler, Command, Event, HandlerResult, Message, Generator, Editor} from './Handlers'
import {TreeNode, Match, PathExpression} from '../tree/PathExpression'
import {Project} from '../model/Core'

/**

Proposal:
- Rename Handler to EventHandler
- Remove Executors, and introduce CommandHandlers and Executions

- CommandHandlers handle Commands (duh)
- Commands are initiated by the bot/slack etc
- Commands can register bot intent
- Commands can have access to secrets
- They are basically the things that @cd uses to do all his fancy botlets.

- Both Event and Command Handlers return HandlerResult | Message
- HandlerResult can contain Executions.
- Executions are just data that represent deferred execution
  of some function that (currently) lives in the JVM in the ExecutionRegistry
  (formally CommandRegistry?).
- Success/Errors from Executions can be handled by registering callbacks.
  These callbacks return HandlerResults too!
- Executions
- Queries are (nearly) always performed via PathExpressions
   - A query is a non-side-effecting retrieval of some data

- Success/Error responses are in a standard format (as per HTTP)
   - code
   - status
   - body - this can be anything at all, even a JVM object

Rationale:
- Easy to explain: rugs can be done via CLI, Handlers are at runtime
- Programming model is asynchronous everywhere!
- First class bot Commands required!
- Executors mode was confusing

QUESTION:
- How do we get things like the PXE in to CommandHandlers?
   - perhaps a "context" type thing with the PXE and other stuff on it?
- Should reviewers be exposed via PXE?
- Should we externalise parameter definitions for rugs and make them common across DSL and TS?
- How do we easily allow chaining of executions (if at all)?
   - allow onSuccess also be an execution?
TODO:
- Add error/success callbacks to editors/generators/reviewers

**/


//NOTE: use case 1: Reopen an issue twice and handle success/failure

export let simpleHandler: EventHandler<Issue,Issue> = {
  name: "ClosedIssueReopener",
  description: "Reopens closed issues",
  tags: ["github", "issues"],
  expression: new ClosedIssues(),
  handle(event: Event<Match<Issue,Issue>>): HandlerResult {
    let issue = event.child().root()
    return new HandlerResult()
      .addExecution(issue.reopen()
                      .onSuccess({text: `Issue ${issue.number()} has been reopened successfully`})
                      .onError(sendFailureMessage))
  }
}

// try to reopen the issue one more time!
function sendFailureMessage(error: ExecutionResponse<Issue>) : HandlerResult {
  let issue = error.body
  return new HandlerResult()
    .addMessage(new Message(`Issue ${issue.number()} was not reopened, trying again`))
    .addExecution(issue.reopen().onError(new Message(`Issue ${issue.number()} was not reopened. Giving up!`)))
}

//NOTE use case 2: run an editor/reviewer across a bunch of repos (the old Executor)

export let licenseAdder: CommandHandler<AddLicenseCommand> = {
  name: "LicenseAdder",
  description: "Runs the SetLicense editor on a bunch of my repos",
  tags: ["github", "license"],
  intent: ["add license"],
  params: [{ name: "license", description: "The name of the license", pattern: "^.*$"}],
  handle(command: AddLicenseCommand) : HandlerResult {
    let result = new HandlerResult()
    let match: Match<TreeNode,Project> = command.patchExpressionEngine().evaluate<TreeNode,Project>("/github/atomist/repo")
    match.matches().forEach(project => {
      result = result.addEditor(project, "AddLicenseFile", {licenseName: command.license()})
    })
    return result;
  }
}

interface AddLicenseCommand extends Command{
  name: string
  license(): string
}

//NOTE: use case 3: handle a Command from the bot (via intent or otherwise)
//1. First class intent
//2. First class secrets
//3. As per other Rugs - declared params are passed in to the command
export let listIssuesHandler: CommandHandler<ListIssuesCommand> = {
  name: "ListIssuesHandler",
  description: "Lists open github issues in slack",
  tags: ["github", "issues"],
  intent: ["list issues"],
  params: [{ name: "days", description: "Days", pattern: "^.*$", maxLength: 100, required: false, default: "1" }],
  secrets: [{name: "token", path: "atomist/github/user_token=repo"}],
  handle(command: ListIssuesCommand) : Message {
    let result = new HandlerResult()
    let match: Match<Issue,Issue> = command.patchExpressionEngine().evaluate<Issue,Issue>("/issues")

    let issues = match.matches();
    if (issues.length > 0) {
              let attachments = `{"attachments": [` + issues.map(i => {
                 let text = JSON.stringify(`#${i.number()}: ${i.title()}`)
                 if (i.state() == "closed") {
                     return `{
                   "fallback": ${text},
                   "author_icon": "http://images.atomist.com/rug/issue-closed.png",
                   "color": "#bd2c00",
                   "author_link": "${i.issueUrl()}",
                   "author_name": ${text}
                }`
                 }
                 else {
                     return `{
                 "fallback": ${text},
                 "author_icon": "http://images.atomist.com/rug/issue-open.png",
                 "color": "#6cc644",
                 "author_link": "${i.issueUrl()}",
                 "author_name": ${text}
              }`
                 }
             }).join(",") + "]}"
             return {text: attachments}
         }else{
            return {text: "You are not crushin' it right now!"}
         }
  }
}

interface ListIssuesCommand extends Command {
  days(): number
  token(): string
}

// NOTE: use case 4: search youtube for kitty videos and post results to slack
// no params - just take Command
export let kitties: CommandHandler<Command> = {
  name: "ShowMeTheKitties",
  description: "Search Youtube for kitty videos and post results to slack",
  tags: ["kitty", "youtube", "slack"],
  intent: ["show me kitties"],
  handle(command: Command) : HandlerResult {
    let result = new HandlerResult()
    result.addExecution({name: "HTTP",
                        params: {method: "GET", url: "http://youtube.com?search=kitty&safe=true", as: "JSON"},
                        onSuccess: showKitties,
                        onError: {text: "No kitties for you today!"}})
    return result;
  }
}

function showKitties(response: ExecutionResponse<Object>) : Message {
  let results = response.body as any;
  return new Message(results.urls.join(","))
}

// stuff associated with types/executions that should have typings

interface Issue extends TreeNode {
  reopen(): Execution<ExecutionResponse<Issue>, ExecutionResponse<Issue>>
  title(): string
  number(): string
  state(): string
  issueUrl(): string
}

class ClosedIssues implements PathExpression<Issue,Issue> {
  expression: string = "/issues/[.state() = 'closed']"
}
