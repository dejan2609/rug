import {EventHandler, SuccessResponse, ErrorResponse, Execution, CommandHandler, Command, Event, HandlerResult, Message, Generator, Editor, PathExpression} from './Handlers'
import {TreeNode} from '../tree/PathExpression'


/**

Proposal:
- Rename Handler to EventHandler
- Remove Executors, and introduce CommandHandlers and Executions

- CommandHandlers handle Commands (duh)
- Commands are initiated by the bot/slack etc
- Commands can register bot intent
- Commands can have access to secrets
- They are basically the things that @cd uses to do all his fancy botlets.

- Both Event and Command Handlers return HandlerResult | Message
- HandlerResult can contain Executions.
- Executions are just data that represent deferred execution
  of some function that (currently) lives in the JVM in the ExecutionRegistry
  (formally CommandRegistry?).
- Results/Errors from Executions can be handled by registrying onSuccess
  and onError callbacks respectively. This callbacks return HandlerResults too!

Rationale:
- Easy to explain: rugs can be done via CLI, Handlers are at runtime
- Programming model is asynchronous everywhere!

Questions:
- Should we pass anything else to CommandHandlers for context? e.g. PXE?
- Could we make _all_ queries use PathExpressions?
   - that way, we only need error handlers for Executions!

**/


//use case 1: ReopenIssues and handle results

export let simpleHandler: EventHandler<Issue> = {
  name: "ClosedIssueReopener",
  description: "Reopens closed issues",
  tags: ["github", "issues"],
  expression: new ClosedIssues(),
  handle(event: Event<Issue>): HandlerResult {
    let issue = event.child()
    return new HandlerResult()
      .addExecution(issue.reopen()
                      .onSuccess(sendSuccessMessage)
                      .onError(sendFailureMessage))
  }
}

function sendSuccessMessage(issue: OpenedIssue) : HandlerResult{
  return new HandlerResult().addMessage(new Message(`Issue ${issue.number()} has been reopened successfully`))
}

function sendFailureMessage(error: IssueReopenError) : HandlerResult {
  return new HandlerResult()
    .addMessage(new Message(`Issue ${error.number()} was not reopened, trying again`))
    .addExecution(error.retry().onError(new Message(`Issue ${error.number()} was not reopened. Giving up!`)))
    .addExecution({name: "sendEmail", params: {subject: "This keeps failing", to: "woot@atomist.com"}})
}

interface IssueReopenError extends ErrorResponse{
  number() : string
  retry(): Execution<OpenedIssue,IssueReopenError>
}

interface OpenedIssue extends SuccessResponse {
  number() : string
}

interface Issue extends TreeNode {
  reopen(): Execution<OpenedIssue, IssueReopenError>
  title(): string
  number(): string
  state(): string
  issueUrl(): string
}

class ClosedIssues extends PathExpression<Issue> {
  expression: string = ""

}

// use case 2: run an editor/reviewer across a bunch of repos (the old Executor)
//NOTE: it might be nice if we could use Path Expressions to search repos!
//      even if they are not in neo - we could intercept the query and call it.
//NOTE: Maybe all "queries" should be via path expressions then Execution callbacks are really about error handling!

export let licenseAdder: CommandHandler<AddLicenseCommand> = {
  name: "LicenseAdder",
  description: "Runs the SetLicense editor on a bunch of my repos",
  tags: ["github", "license"],
  intent: ["add license"],
  params: [{ name: "license", description: "The name of the license", pattern: "^.*$"}],
  handle(command: AddLicenseCommand) : HandlerResult {
    return new HandlerResult()
      .addExecution({name: "list-github-repos",
                      params: {org: "atomist", matching: "^.*-editors$"},
                      onSuccess: (repos: Repos) => {
                        let result = new HandlerResult();
                        for(var name of repos.names){
                          result = result.addEditor("AddLicenseFile", {licenseName: command.license()})
                        }
                      }})
    }
}

interface Repos extends SuccessResponse{
  names: string[]
}

interface GithubError extends ErrorResponse {}

interface AddLicenseCommand extends Command{
  name: string
  license(): string
}

// use case 3: handle a Command from the bot (via intent or otherwise)
//example return just data
//NOTE: would listing issues just be a PathExpression?
export let listIssuesHandler: CommandHandler<ListIssuesCommand> = {
  name: "ListIssuesHandler",
  description: "Lists open github issues in slack",
  tags: ["github", "issues"],
  intent: ["list issues"],
  params: [{ name: "days", description: "Days", pattern: "^.*$", maxLength: 100, required: false, default: "1" }],
  secrets: [{name: "token", path: "atomist/github/user_token=repo"}],
  handle(command: ListIssuesCommand) : HandlerResult {
    return {executions: [{name: "list-github-issues",
                    params: {repo: command.token(), days: command.days()},
                    onError: {text: "Something went wrong. Best ask @cd about it."},
                    onSuccess: displayIssues}]}
  }
}

interface ListIssuesCommand extends Command {
  days(): number
  token(): string
}

//example return just data. In this instance, we need to know that we'll be passed Issue[]
function displayIssues(issues: Issue[]) : Message {
  if (issues.length > 0) {
            let attachments = `{"attachments": [` + issues.map(i => {
               let text = JSON.stringify(`#${i.number()}: ${i.title()}`)
               if (i.state() == "closed") {
                   return `{
                 "fallback": ${text},
                 "author_icon": "http://images.atomist.com/rug/issue-closed.png",
                 "color": "#bd2c00",
                 "author_link": "${i.issueUrl()}",
                 "author_name": ${text}
              }`
               }
               else {
                   return `{
               "fallback": ${text},
               "author_icon": "http://images.atomist.com/rug/issue-open.png",
               "color": "#6cc644",
               "author_link": "${i.issueUrl()}",
               "author_name": ${text}
            }`
               }
           }).join(",") + "]}"
           return {text: attachments}
       }else{
          return {text: "You are not crushin' it right now!"}
       }
}

// use case 4: search youtube for kitty videos and post results to slack

// interface SearchYoutubeCommand extends Command{
//     query: string
// }
//
// export let youTubeSearcher: CommandHandler<SearchYoutubeCommand> = {
//   name: "YoutubeSearcher",
//   description: "Searches youtube and publishes the results to slack",
//   tags: ["slack", "youtube"],
//   handle(event: Event<SearchYoutubeCommand>){
//     let res = event.child()
//     return new HandlerResult()
//       .addMessage(new Message(res))
//       .addCommand(issue.reopen())
//   }
// }
