import {TreeNode, PathExpressionEngine, PathExpression, Match} from "../tree/PathExpression"
import {Parameter} from "./RugOperation"
import {Project} from "../model/Core"

interface RugCoordinate {
  group: string
  artifact: string
  version?: string
  name: string
}

interface Rug {
  readonly name: string | RugCoordinate
  readonly params: {}
  readonly kind: "generator" | "editor" | "reviewer"
}

abstract class Generator implements Rug {
  abstract name: string
  abstract params: {}
  kind: "generator"
}

abstract class Editor implements Rug {
  abstract name: string
  abstract params: {}
  abstract project: Project
  kind: "editor"
}

abstract class Reviewer implements Rug {
  abstract name: string
  abstract params: {}
  abstract project: Project
  kind: "reviewer"
}

interface Event<R> {
  child(): R
}

interface Secret{
  name: string
  path: string
}

interface CommandHandler<T extends Command>{
  intent?: string[]
  params?: Parameter[]
  secrets?: Secret[]
  readonly name: string
  readonly description: string
  readonly tags?: string[]
  handle(root: T): HandlerResult | Message
}

interface EventHandler<R extends TreeNode, M extends TreeNode> {
  readonly name: string
  readonly description: string
  readonly tags?: string[]
  readonly expression: PathExpression<R,M>
  handle(root: Event<Match<R,M>>): HandlerResult | Message
}

interface Command {
  name: string
  params?: {}
  patchExpressionEngine(): PathExpressionEngine
}

interface ExecutionResponse<T> {
  status: string
  code: number
  body?: T //this could be a JVM object such as an Issue
}

type ExecutionResponseHandler<T> = (success: ExecutionResponse<T>) => HandlerResult | Message

interface DataExecution{
  name: string
  params?: {}
  onSuccess?: HandlerResult | Message
  onError?: HandlerResult | Message
}

interface Execution<E,S> {
  name: string
  params?: {}
  onSuccess(sucess: ExecutionResponseHandler<E> | HandlerResult | Message) : this
  onError(error: ExecutionResponseHandler<S> | HandlerResult | Message) : this
}

class HandlerResult {
   messages?: Message[] = [];
   rugs?: Rug[]
   executions?: (Execution<any,any> | DataExecution) [] = [];

   public addMessage?(message: Message) : this{
     this.messages.push(message)
     return this;
   }

   public addExecution?(exec: Execution<any,any> | DataExecution) : this {
     this.executions.push(exec);
     return this;
   }


   public addEditor?(project: Project, rug: string | Rug, parameters?: {}) : this {
     if(typeof rug == 'string'){
       this.rugs.push({name: rug, params: parameters, kind: "editor", project: project} as Editor)
     }else{
       let editor = rug as Editor
       editor.project = project
       this.rugs.push(editor)
     }
     return this
   }
   public addEditor?(project: Project, rug: Rug): this

   public addGenerator?(rug: Rug) : this {
     this.rugs.push(rug)
     return this;
   }
}

class Message {
  text?: string;
  channelId?: string;
  regarding?: TreeNode;

  private rugs?: Rug[] = []
  private executions?: (Execution<any,any> | DataExecution) [] = [];

  constructor(about: TreeNode | string){
    if(typeof about == 'string'){
        this.text = about;
    }else{
      this.regarding = about;
    }
  }

  public addExecution?(exec: Execution<any,any> | DataExecution) : this {
    this.executions.push(exec);
    return this;
  }

  public addEditor?(rug: Editor): this {
    this.rugs.push(rug)
    return this;
  }

  public addGenerator?(rug: Generator) : this {
    this.rugs.push(rug)
    return this;
  }
}

export {CommandHandler, Secret, EventHandler, ExecutionResponse, Execution, Command, Event, HandlerResult, Message, Generator, Editor, PathExpression}
