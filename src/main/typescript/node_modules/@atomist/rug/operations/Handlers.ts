import {TreeNode, PathExpressionEngine} from "../tree/PathExpression"
import {Parameter} from "./RugOperation"

interface RugCoordinate {
  group: string
  artifact: string
  version?: string
  name: string
}

interface Rug {
  readonly name: string | RugCoordinate
  readonly params: {}
  readonly kind: "generator" | "editor"
}

abstract class Generator implements Rug {
  abstract name: string
  abstract params: {}
  kind: "generator"
}

abstract class Editor implements Rug {
  abstract name: string
  abstract params: Object
  kind: "editor"
}

interface Event<R> {
  child(): R
}

abstract class PathExpression<T extends TreeNode> {
  readonly expression: string
  readonly kind: T
}


interface Secret{
  name: string
  path: string
}

interface CommandHandler<T extends Command>{
  intent?: string[]
  params?: Parameter[]
  secrets?: Secret[]
  readonly name: string
  readonly description: string
  readonly tags?: string[]
  handle(root: T): HandlerResult | Message
}

interface EventHandler<T extends TreeNode> {
  readonly name: string
  readonly description: string
  readonly tags?: string[]
  readonly expression: PathExpression<T>
  handle(root: Event<T>): HandlerResult | Message
}

interface Command {
  name: string
  params?: {}
}

interface SuccessResponse {
  status: string
  code: number
}

interface ErrorResponse {
  status: string
  code: number
}

type SuccessHandler<S extends SuccessResponse> = (success: S) => HandlerResult | Message
type ErrorHandler<E extends ErrorResponse> = (error: E) => HandlerResult | Message

interface DataExecution<S extends SuccessResponse,E extends ErrorResponse> {
  name: string
  params?: {}
  onSuccess?: HandlerResult | Message
  onError?: HandlerResult | Message
}

interface Execution<S extends SuccessResponse,E extends ErrorResponse> {
  name: string
  params?: {}
  onSuccess(sucess: SuccessHandler<S> | HandlerResult | Message) : this
  onError(error: ErrorHandler<E> | HandlerResult | Message) : this
}

class HandlerResult {
   messages?: Message[] = [];
   rugs?: Rug[]
   executions?: (Execution<any,any> | DataExecution<any,any>) [] = [];

   public addMessage?(message: Message) : this{
     this.messages.push(message)
     return this;
   }

   public addExecution?(exec: Execution<any,any> | DataExecution<any,any>) : this {
     this.executions.push(exec);
     return this;
   }


   public addEditor?(rug: string | Editor, parameters?: {}) : this {
     if(typeof rug == 'string'){
       this.rugs.push({name: rug, params: parameters, kind: "editor"})
     }else{
       this.rugs.push(rug)
     }
     return this
   }
   public addEditor?(rug: Editor): this

   public addGenerator?(rug: Generator) : this {
     this.rugs.push(rug)
     return this;
   }
}

class Message {
  text?: string;
  channelId?: string;
  regarding?: TreeNode;

  private rugs?: Rug[] = []
  private executions?: (Execution<any,any> | DataExecution<any,any>) [] = [];

  constructor(about: TreeNode | string){
    if(typeof about == 'string'){
        this.text = about;
    }else{
      this.regarding = about;
    }
  }

  public addExecution?(exec: Execution<any,any> | DataExecution<any,any>) : this {
    this.executions.push(exec);
    return this;
  }

  public addEditor?(rug: Editor): this {
    this.rugs.push(rug)
    return this;
  }

  public addGenerator?(rug: Generator) : this {
    this.rugs.push(rug)
    return this;
  }
}

export {CommandHandler, Secret, EventHandler, SuccessResponse, ErrorResponse, Execution, Command, Event, HandlerResult, Message, Generator, Editor, PathExpression}
